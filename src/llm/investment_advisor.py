"""자연언어 인터페이스를 갖춘 LLM 기반 투자 자문가."""

import asyncio
import json
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum

from loguru import logger

from src.llm.openai_client import OpenAIFinancialAnalyst, LLMAnalysisRequest, LLMAnalysisResponse
from src.database.connection import db_client
from src.database.schema import InvestmentRecommendation


class QueryType(str, Enum):
    """투자 쿼리 유형."""
    COMPANY_ANALYSIS = "company_analysis"
    SECTOR_COMPARISON = "sector_comparison"
    PORTFOLIO_ADVICE = "portfolio_advice"
    RISK_ASSESSMENT = "risk_assessment"
    MARKET_OUTLOOK = "market_outlook"
    INVESTMENT_STRATEGY = "investment_strategy"


@dataclass
class AdvisorQuery:
    """투자 자문가 쿼리 구조."""
    query_id: str
    user_query: str
    query_type: QueryType
    companies: List[str] = None
    timeframe: Optional[str] = None
    risk_tolerance: Optional[str] = None  # conservative, moderate, aggressive
    investment_amount: Optional[float] = None
    context: Optional[Dict[str, Any]] = None


@dataclass
class AdvisorResponse:
    """투자 자문가 응답 구조."""
    query_id: str
    response_text: str
    recommendations: List[Dict[str, Any]]
    supporting_analysis: Dict[str, Any]
    confidence_level: float
    disclaimer: str
    timestamp: datetime
    model_used: str


class LLMInvestmentAdvisor:
    """ChatGPT로 구동되는 고급 투자 자문가."""
    
    def __init__(self):
        self.analyst = OpenAIFinancialAnalyst()
        self.disclaimer = """
IMPORTANT DISCLAIMER: This analysis is generated by AI and is for informational purposes only. 
It should not be considered as personalized investment advice. Always consult with qualified 
financial advisors and conduct your own research before making investment decisions. Past 
performance does not guarantee future results.
"""
    
    async def process_query(self, query: AdvisorQuery) -> AdvisorResponse:
        """투자 쿼리를 처리하고 종합적인 조언을 반환합니다."""
        logger.info(f"Processing investment query: {query.query_type} - {query.query_id}")
        
        try:
            if query.query_type == QueryType.COMPANY_ANALYSIS:
                return await self._handle_company_analysis(query)
            elif query.query_type == QueryType.SECTOR_COMPARISON:
                return await self._handle_sector_comparison(query)
            elif query.query_type == QueryType.PORTFOLIO_ADVICE:
                return await self._handle_portfolio_advice(query)
            elif query.query_type == QueryType.RISK_ASSESSMENT:
                return await self._handle_risk_assessment(query)
            elif query.query_type == QueryType.MARKET_OUTLOOK:
                return await self._handle_market_outlook(query)
            else:
                return await self._handle_general_strategy(query)
                
        except Exception as e:
            logger.error(f"Error processing query {query.query_id}: {e}")
            return self._create_error_response(query, str(e))
    
    async def _handle_company_analysis(self, query: AdvisorQuery) -> AdvisorResponse:
        """기업별 분석 쿼리를 처리합니다."""
        if not query.companies or len(query.companies) == 0:
            return self._create_error_response(query, "No companies specified for analysis")
        
        company_ticker = query.companies[0].upper()
        
        # Get latest analysis from database
        analysis_history = await db_client.get_company_analysis_history(company_ticker)
        
        if not analysis_history:
            return self._create_error_response(
                query, 
                f"No analysis data available for {company_ticker}. Please run the pipeline first."
            )
        
        latest_analysis = analysis_history[0]
        
        # Get qualitative sections for LLM analysis
        sections_data = await self._get_company_sections(company_ticker)
        
        if sections_data:
            # Perform fresh LLM analysis
            llm_request = LLMAnalysisRequest(
                company_ticker=company_ticker,
                fiscal_year=latest_analysis.get("fiscal_year", 2024),
                sections_data=sections_data,
                quantitative_scores={
                    "qualitative_score": latest_analysis.get("qualitative_score", 50) / 100,
                    "confidence": latest_analysis.get("confidence", 0.5)
                },
                analysis_type="comprehensive",
                context={"user_query": query.user_query}
            )
            
            llm_analysis = await self.analyst.analyze_comprehensive(llm_request)
            
            # Generate conversational response
            response_text = await self._generate_company_response(
                query.user_query, company_ticker, latest_analysis, llm_analysis
            )
            
            recommendations = [
                {
                    "ticker": company_ticker,
                    "recommendation": llm_analysis.investment_recommendation,
                    "confidence": llm_analysis.confidence_level,
                    "rationale": llm_analysis.investment_thesis,
                    "key_points": llm_analysis.key_strengths[:3]
                }
            ]
            
        else:
            # Fallback to database-only analysis
            response_text = await self._generate_database_response(
                query.user_query, company_ticker, latest_analysis
            )
            
            recommendations = [
                {
                    "ticker": company_ticker,
                    "recommendation": latest_analysis.get("recommendation", "Hold"),
                    "confidence": latest_analysis.get("confidence", 0.5),
                    "score": latest_analysis.get("qualitative_score", 50),
                    "rationale": "Based on quantitative analysis of 10-K filing"
                }
            ]
        
        return AdvisorResponse(
            query_id=query.query_id,
            response_text=response_text,
            recommendations=recommendations,
            supporting_analysis={"company_data": latest_analysis},
            confidence_level=0.8,
            disclaimer=self.disclaimer,
            timestamp=datetime.now(),
            model_used=self.analyst.model
        )
    
    async def _handle_portfolio_advice(self, query: AdvisorQuery) -> AdvisorResponse:
        """포트폴리오 구성 및 조언 쿼리를 처리합니다."""
        
        # Get top recommendations from database
        recommendations = await db_client.get_investment_recommendations(limit=20)
        
        if not recommendations:
            return self._create_error_response(
                query, "No investment recommendations available. Please run the analysis pipeline first."
            )
        
        # Prepare portfolio analysis prompt
        portfolio_data = []
        for rec in recommendations[:15]:
            portfolio_data.append({
                "ticker": rec.get("ticker"),
                "recommendation": rec.get("recommendation"),
                "score": rec.get("qualitative_score"),
                "confidence": rec.get("confidence")
            })
        
        prompt = f"""As a portfolio manager, provide investment advice based on this query: "{query.user_query}"

Risk Tolerance: {query.risk_tolerance or 'Moderate'}
Investment Amount: ${query.investment_amount or 'Not specified'}
Timeframe: {query.timeframe or 'Not specified'}

Available Investment Options (from 10-K analysis):
{json.dumps(portfolio_data, indent=2)}

Provide a comprehensive response covering:
1. Personalized portfolio recommendations
2. Asset allocation suggestions
3. Risk management considerations
4. Timing and implementation strategy
5. Specific ticker recommendations with weightings

Format as natural, conversational advice."""

        try:
            response = await self.analyst.client.chat.completions.create(
                model=self.analyst.model,
                messages=[
                    {
                        "role": "system", 
                        "content": "You are a senior portfolio manager providing personalized investment advice based on fundamental analysis."
                    },
                    {"role": "user", "content": prompt}
                ],
                max_tokens=2000,
                temperature=0.4
            )
            
            response_text = response.choices[0].message.content
            
            # Extract top recommendations based on user preferences
            if query.risk_tolerance == "conservative":
                filtered_recs = [r for r in recommendations if r.get("recommendation") in ["Buy", "Hold"]][:5]
            elif query.risk_tolerance == "aggressive":
                filtered_recs = [r for r in recommendations if r.get("recommendation") == "Strong Buy"][:5]
            else:
                filtered_recs = recommendations[:5]
            
            portfolio_recommendations = []
            for rec in filtered_recs:
                portfolio_recommendations.append({
                    "ticker": rec.get("ticker"),
                    "recommendation": rec.get("recommendation"),
                    "allocation_suggestion": f"{100 // len(filtered_recs)}%",
                    "rationale": f"Score: {rec.get('qualitative_score', 50):.1f}/100"
                })
            
            return AdvisorResponse(
                query_id=query.query_id,
                response_text=response_text,
                recommendations=portfolio_recommendations,
                supporting_analysis={
                    "risk_tolerance": query.risk_tolerance,
                    "total_companies_analyzed": len(recommendations)
                },
                confidence_level=0.7,
                disclaimer=self.disclaimer,
                timestamp=datetime.now(),
                model_used=self.analyst.model
            )
            
        except Exception as e:
            logger.error(f"Error in portfolio advice: {e}")
            return self._create_error_response(query, f"Portfolio analysis error: {str(e)}")
    
    async def _handle_sector_comparison(self, query: AdvisorQuery) -> AdvisorResponse:
        """섹터 비교 및 분석을 처리합니다."""
        
        # Get all recommendations
        all_recommendations = await db_client.get_investment_recommendations(limit=50)
        
        # Group by sectors (simplified - would need sector classification)
        tech_companies = ["AAPL", "MSFT", "GOOGL", "AMZN", "NVDA", "META", "NFLX", "ADBE"]
        healthcare_companies = ["AMGN", "GILD", "BIIB", "REGN", "VRTX", "MRNA", "DXCM", "ISRG"]
        
        tech_recs = [r for r in all_recommendations if r.get("ticker") in tech_companies]
        healthcare_recs = [r for r in all_recommendations if r.get("ticker") in healthcare_companies]
        
        prompt = f"""Provide a sector comparison analysis based on the user query: "{query.user_query}"

Technology Sector Performance:
{json.dumps([{'ticker': r.get('ticker'), 'score': r.get('qualitative_score'), 'rec': r.get('recommendation')} for r in tech_recs[:10]], indent=2)}

Healthcare Sector Performance:
{json.dumps([{'ticker': r.get('ticker'), 'score': r.get('qualitative_score'), 'rec': r.get('recommendation')} for r in healthcare_recs[:10]], indent=2)}

Provide insights on:
1. Sector performance comparison
2. Best opportunities in each sector
3. Risk factors by sector
4. Investment timing considerations
5. Diversification recommendations"""

        try:
            response = await self.analyst.client.chat.completions.create(
                model=self.analyst.model,
                messages=[
                    {"role": "system", "content": "You are a sector analyst providing comparative investment analysis."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1500,
                temperature=0.3
            )
            
            return AdvisorResponse(
                query_id=query.query_id,
                response_text=response.choices[0].message.content,
                recommendations=[],
                supporting_analysis={
                    "tech_sector_avg": sum(r.get("qualitative_score", 50) for r in tech_recs) / len(tech_recs) if tech_recs else 0,
                    "healthcare_sector_avg": sum(r.get("qualitative_score", 50) for r in healthcare_recs) / len(healthcare_recs) if healthcare_recs else 0
                },
                confidence_level=0.6,
                disclaimer=self.disclaimer,
                timestamp=datetime.now(),
                model_used=self.analyst.model
            )
            
        except Exception as e:
            return self._create_error_response(query, f"Sector analysis error: {str(e)}")
    
    async def _handle_risk_assessment(self, query: AdvisorQuery) -> AdvisorResponse:
        """리스크 평가 쿼리를 처리합니다."""
        if query.companies:
            company_ticker = query.companies[0].upper()
            sections_data = await self._get_company_sections(company_ticker)
            
            if sections_data and "risk_factors" in sections_data:
                # Use LLM for detailed risk analysis
                llm_request = LLMAnalysisRequest(
                    company_ticker=company_ticker,
                    fiscal_year=2024,
                    sections_data={"risk_factors": sections_data["risk_factors"]},
                    quantitative_scores={},
                    analysis_type="risk_assessment"
                )
                
                risk_analysis = await self.analyst.analyze_risk_assessment(llm_request)
                
                prompt = f"""Based on the detailed risk analysis, provide a conversational response to: "{query.user_query}"

Risk Analysis Results:
{json.dumps(risk_analysis, indent=2)}

Provide practical investment advice focusing on risk management and mitigation strategies."""

                response = await self.analyst.client.chat.completions.create(
                    model=self.analyst.model,
                    messages=[
                        {"role": "system", "content": "You are a risk management specialist providing investment guidance."},
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=1200,
                    temperature=0.2
                )
                
                return AdvisorResponse(
                    query_id=query.query_id,
                    response_text=response.choices[0].message.content,
                    recommendations=[],
                    supporting_analysis=risk_analysis,
                    confidence_level=0.8,
                    disclaimer=self.disclaimer,
                    timestamp=datetime.now(),
                    model_used=self.analyst.model
                )
        
        return self._create_error_response(query, "Risk assessment requires specific company analysis")
    
    async def _handle_market_outlook(self, query: AdvisorQuery) -> AdvisorResponse:
        """시장 전망 및 일반적인 투자 쿼리를 처리합니다."""
        
        # Get market overview data
        recommendations = await db_client.get_investment_recommendations(limit=30)
        
        market_stats = {
            "total_analyzed": len(recommendations),
            "strong_buy_count": len([r for r in recommendations if r.get("recommendation") == "Strong Buy"]),
            "buy_count": len([r for r in recommendations if r.get("recommendation") == "Buy"]),
            "hold_count": len([r for r in recommendations if r.get("recommendation") == "Hold"]),
            "avg_score": sum(r.get("qualitative_score", 50) for r in recommendations) / len(recommendations) if recommendations else 0
        }
        
        prompt = f"""Based on the current market analysis, respond to: "{query.user_query}"

Market Overview (from 10-K qualitative analysis):
- Total companies analyzed: {market_stats['total_analyzed']}
- Strong Buy recommendations: {market_stats['strong_buy_count']}
- Buy recommendations: {market_stats['buy_count']}
- Hold recommendations: {market_stats['hold_count']}
- Average qualitative score: {market_stats['avg_score']:.1f}/100

Provide insights on current market conditions, investment opportunities, and strategic considerations based on fundamental analysis of major companies."""

        try:
            response = await self.analyst.client.chat.completions.create(
                model=self.analyst.model,
                messages=[
                    {"role": "system", "content": "You are a market strategist providing investment outlook based on fundamental analysis."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1500,
                temperature=0.4
            )
            
            return AdvisorResponse(
                query_id=query.query_id,
                response_text=response.choices[0].message.content,
                recommendations=[],
                supporting_analysis=market_stats,
                confidence_level=0.6,
                disclaimer=self.disclaimer,
                timestamp=datetime.now(),
                model_used=self.analyst.model
            )
            
        except Exception as e:
            return self._create_error_response(query, f"Market outlook error: {str(e)}")
    
    async def _handle_general_strategy(self, query: AdvisorQuery) -> AdvisorResponse:
        """일반적인 투자 전략 쿼리를 처리합니다."""
        
        prompt = f"""As an experienced investment advisor, provide comprehensive guidance for this query: "{query.user_query}"

Consider:
- Current market conditions
- Risk management principles
- Diversification strategies
- Long-term vs short-term perspectives
- Fundamental analysis approaches

Provide actionable, educational investment advice."""

        try:
            response = await self.analyst.client.chat.completions.create(
                model=self.analyst.model,
                messages=[
                    {"role": "system", "content": "You are a senior investment advisor with 20+ years of experience providing strategic investment guidance."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1500,
                temperature=0.5
            )
            
            return AdvisorResponse(
                query_id=query.query_id,
                response_text=response.choices[0].message.content,
                recommendations=[],
                supporting_analysis={},
                confidence_level=0.7,
                disclaimer=self.disclaimer,
                timestamp=datetime.now(),
                model_used=self.analyst.model
            )
            
        except Exception as e:
            return self._create_error_response(query, f"Strategy analysis error: {str(e)}")
    
    async def _get_company_sections(self, ticker: str) -> Dict[str, str]:
        """LLM 분석을 위해 기업 섹션을 가져옵니다."""
        try:
            # Get latest filing for the company
            analysis_history = await db_client.get_company_analysis_history(ticker)
            if not analysis_history:
                return {}
            
            # This would retrieve sections from database
            # For now, return empty dict as placeholder
            return {}
            
        except Exception as e:
            logger.error(f"Error retrieving sections for {ticker}: {e}")
            return {}
    
    async def _generate_company_response(self, user_query: str, ticker: str, 
                                       db_analysis: Dict, llm_analysis: LLMAnalysisResponse) -> str:
        """기업 분석을 위한 자연언어 응답을 생성합니다."""
        
        prompt = f"""Generate a conversational, professional response to the user query: "{user_query}"

Company: {ticker}
Database Analysis: {db_analysis.get('recommendation', 'N/A')} (Score: {db_analysis.get('qualitative_score', 'N/A')})
LLM Analysis: {llm_analysis.investment_recommendation}

Key Insights:
{llm_analysis.executive_summary}

Investment Thesis:
{llm_analysis.investment_thesis}

Provide a natural, informative response that directly addresses the user's question."""

        response = await self.analyst.client.chat.completions.create(
            model=self.analyst.model,
            messages=[
                {"role": "system", "content": "You are a helpful investment analyst speaking directly to an investor."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=800,
            temperature=0.4
        )
        
        return response.choices[0].message.content
    
    async def _generate_database_response(self, user_query: str, ticker: str, db_analysis: Dict) -> str:
        """데이터베이스 분석만을 사용하여 응답을 생성합니다."""
        
        prompt = f"""Respond to the user query: "{user_query}" about {ticker}

Available Analysis:
- Recommendation: {db_analysis.get('recommendation', 'N/A')}
- Qualitative Score: {db_analysis.get('qualitative_score', 'N/A')}/100
- Confidence: {db_analysis.get('confidence', 'N/A')}
- Analysis Date: {db_analysis.get('analysis_date', 'N/A')}

Provide a helpful response based on this quantitative analysis."""

        response = await self.analyst.client.chat.completions.create(
            model=self.analyst.model,
            messages=[
                {"role": "system", "content": "You are providing investment insights based on fundamental analysis."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=600,
            temperature=0.3
        )
        
        return response.choices[0].message.content
    
    def _create_error_response(self, query: AdvisorQuery, error_message: str) -> AdvisorResponse:
        """오류 응답을 생성합니다."""
        return AdvisorResponse(
            query_id=query.query_id,
            response_text=f"I apologize, but I encountered an issue processing your request: {error_message}. Please try rephrasing your question or contact support if the issue persists.",
            recommendations=[],
            supporting_analysis={"error": error_message},
            confidence_level=0.0,
            disclaimer=self.disclaimer,
            timestamp=datetime.now(),
            model_used="N/A"
        )
    
    def classify_query(self, user_input: str) -> QueryType:
        """사용자 쿼리를 분류하여 적절한 처리 방법을 결정합니다."""
        user_input_lower = user_input.lower()
        
        if any(word in user_input_lower for word in ["risk", "risks", "risky", "danger", "threat"]):
            return QueryType.RISK_ASSESSMENT
        elif any(word in user_input_lower for word in ["portfolio", "diversify", "allocation", "balance"]):
            return QueryType.PORTFOLIO_ADVICE
        elif any(word in user_input_lower for word in ["compare", "vs", "versus", "sector", "industry"]):
            return QueryType.SECTOR_COMPARISON
        elif any(word in user_input_lower for word in ["market", "outlook", "economy", "trend", "future"]):
            return QueryType.MARKET_OUTLOOK
        elif any(ticker in user_input.upper() for ticker in ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "META", "NVDA"]):
            return QueryType.COMPANY_ANALYSIS
        else:
            return QueryType.INVESTMENT_STRATEGY


async def main():
    """투자 자문가 기능을 테스트합니다."""
    advisor = LLMInvestmentAdvisor()
    
    test_query = AdvisorQuery(
        query_id="test_001",
        user_query="What's your analysis of Apple's investment potential?",
        query_type=QueryType.COMPANY_ANALYSIS,
        companies=["AAPL"],
        risk_tolerance="moderate"
    )
    
    print("Investment Advisor loaded successfully")
    print(f"Test query type: {advisor.classify_query(test_query.user_query)}")


if __name__ == "__main__":
    asyncio.run(main())